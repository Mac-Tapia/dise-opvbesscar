â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                            â•‘
â•‘              ğŸ”„ FLUJO DE DATOS COMPLETO - pvbesscar OE3                   â•‘
â•‘                                                                            â•‘
â•‘       Desde construcciÃ³n de dataset hasta comparaciÃ³n de agentes           â•‘
â•‘                                                                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 1: CONSTRUCCIÃ“N DE DATASET (Layer 1)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   ENTRADA (OE2 Artifacts)
   â”œâ”€ solar/pv_generation_timeseries.csv (8,760 rows, 1 col)
   â”œâ”€ chargers/individual_chargers.json (32 chargers Ã— 4 sockets = 128)
   â”œâ”€ bess/config.json (4,520 kWh capacity)
   â”œâ”€ mall_demand/demand.csv (100 kW baseline)
   â”‚
   â”œâ”€ CLIMATE ZONE DATA (Session 2 Integration)
   â”œâ”€ climate_zone/carbon_intensity.csv (COâ‚‚ grid: 0.4521 kg/kWh)
   â”œâ”€ climate_zone/pricing.csv (tarifa elÃ©ctrica)
   â”œâ”€ climate_zone/weather.csv (temperatura, radiaciÃ³n, etc.)
   â”‚
   â””â”€ CONSTANTES (ya integradas)
      â””â”€ emissions_constants.py:EMISSIONS â†’ schema.json

                         â†“â†“â†“

   dataset_builder_consolidated.py (871 lÃ­neas)
   â”œâ”€ PASO 1: Carga OE2 artifacts vÃ­a OE2DataLoader
   â”œâ”€ PASO 2: Carga climate zone vÃ­a 3 loader methods
   â”‚  â”œâ”€ load_carbon_intensity()
   â”‚  â”œâ”€ load_pricing()
   â”‚  â””â”€ load_weather()
   â”œâ”€ PASO 3: Valida 8,760 timesteps (exacto, sin gaps)
   â”œâ”€ PASO 4: Genera 128 CSV por charger (4,518 lÃ­neas de lÃ³gica)
   â”œâ”€ PASO 5: Genera schema.json con contexto de rewards
   â””â”€ PASO 6: Llama _generate_climate_csvs()

                         â†“â†“â†“

   SALIDA (Generated Artifacts)
   â”œâ”€ outputs/schema_*.json (1 archivo)
   â”‚  â”œâ”€ version, buildings, climate_zones
   â”‚  â”œâ”€ electricity_pricing (de climate_zone)
   â”‚  â””â”€ weather context (de climate_zone)
   â”‚
   â”œâ”€ outputs/charger_1.csv ... charger_128.csv (128 archivos)
   â”‚  â”œâ”€ time, power_setpoint, ev_type, battery_soc, ...
   â”‚  â””â”€ 8,760 rows cada uno (exacto)
   â”‚
   â””â”€ outputs/climate_zone/
      â”œâ”€ carbon_intensity.csv
      â”œâ”€ pricing.csv
      â””â”€ weather.csv

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 2: VALIDACIÃ“N POST-BUILD (Layer 2) - OPCIONAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   schema_validator.py (490 lÃ­neas)
   â”œâ”€ validate_structure() â†’ verifica keys necesarias
   â”œâ”€ validate_data_integrity() â†’ 8,760 rows, sin gaps
   â”œâ”€ validate_building_data() â†’ archivos existen
   â”œâ”€ validate_charger_files() â†’ 128 CSV presentes
   â””â”€ validate_value_ranges() â†’ valores en rangos esperados

                         â†“â†“â†“

   Resultado: âœ… Schema VALIDADO o âŒ ERRORES reportados

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 3: CARGA EN CITYLEARN (Layer 3)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   CityLearn v2 Environment
   â”œâ”€ Carga schema.json
   â”œâ”€ Lee 128 CSV + datos clima
   â”œâ”€ Inicializa espacios:
   â”‚  â”œâ”€ observation_space: Box(394,)
   â”‚  â””â”€ action_space: Box(129,)
   â””â”€ Estado inicial: t=0, SOC=50%, observables listos

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 4: ENRIQUECIMIENTO DE OBSERVABLES (Layer 4) - DURANTE TRAINING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   enriched_observables.py
   â”œâ”€ AÃ±ade flags de hora:
   â”‚  â”œâ”€ peak_hours: [18, 19, 20, 21]
   â”‚  â””â”€ valley_hours: [9, 10, 11, 12]
   â”œâ”€ Calcula SOC target dinÃ¡mico
   â”‚  â”œâ”€ normal_hours: 60%
   â”‚  â”œâ”€ pre_peak_hours: 85%
   â”‚  â””â”€ during_peak_hours: 40%
   â”œâ”€ LÃ­mites potencia por playa
   â”‚  â”œâ”€ playa_motos: 120 kW
   â”‚  â”œâ”€ playa_mototaxis: 48 kW
   â”‚  â””â”€ total_aggregate: 150 kW
   â””â”€ Penalizaciones operacionales

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 5: MONITOREO DE CHARGERS (Layer 5) - DURANTE TRAINING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   charger_monitor.py (318 lÃ­neas)
   â”œâ”€ ChargerMonitor.get_charger_type(id) â†’ "moto" | "mototaxi"
   â”œâ”€ ChargerMonitor.get_charger_max_power(id) â†’ 2kW | 3kW
   â””â”€ ChargerMonitor.calculate_charge_priority():
      â”œâ”€ Factores: capacity_factor, time_urgency, energy_factor
      â””â”€ Priority [0,1]: 1=mÃ¡xima urgencia, 0=sin urgencia

   Uso en callbacks: Loguea estado de chargers cada step

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 6: ANÃLISIS DE CURVAS DE DEMANDA (Layer 6) - POST-STEP OPTIONAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   demand_curve.py (349 lÃ­neas)
   â”œâ”€ get_typical_mall_demand(hour) â†’ Demanda mall por hora
   â”‚  â”œâ”€ 00-05h: 80 kW (nocturno)
   â”‚  â”œâ”€ 05-09h: 150 kW
   â”‚  â”œâ”€ 18-21h: 350 kW (PICO)
   â”‚  â””â”€ etc.
   â”œâ”€ get_typical_ev_demand(hour) â†’ Demanda EVs por hora
   â”‚  â”œâ”€ 05-09h: Mayor (usuarios llegan)
   â”‚  â”œâ”€ 16-20h: Mayor (ir al trabajo)
   â”‚  â””â”€ etc.
   â””â”€ analyze_demand_stability() â†’ Variabilidad

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 7: DESPACHO INTELIGENTE DE ENERGÃA (Layer 7) - BASELINE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   dispatcher.py (423 lÃ­neas) - fixed_schedule.py usa este

   Reglas de Prioridad (SOLAR â†’ BESS â†’ GRID):

   Priority 1: SOLAR â†’ CARGA DE EVs (mÃ¡xima)
              â””â”€ Goal: Cargar EVs con FV (cero emisiones)

   Priority 2: SOLAR EXCESO â†’ BESS
              â””â”€ Goal: Acumular FV para la tarde

   Priority 3: SOLAR EXCESO â†’ DEMANDA REAL MALL
              â””â”€ Goal: Usar FV directo (cero importaciÃ³n)

   Priority 4: BESS MAÃ‘ANA â†’ Cargar (durante FV)
              â””â”€ Goal: Preparar BESS para pico (tarde)

   Priority 5: BESS TARDE/NOCHE â†’ Descargar SOLO EVs
              â””â”€ Goal: Descargar para EVs, NO para mall

   Priority 6: GRID IMPORT â†’ Solo si deficit total
              â””â”€ Goal: Minimizar importaciÃ³n (0.4521 kg COâ‚‚/kWh)

   Datos:
   â”œâ”€ Input: energy_balance_t
   â”‚  â”œâ”€ solar_generation_kw
   â”‚  â”œâ”€ mall_demand_kw
   â”‚  â”œâ”€ ev_demand_total_kw
   â”‚  â”œâ”€ bess_soc_percent
   â”‚  â”œâ”€ grid_carbon_intensity: 0.4521 kg COâ‚‚/kWh
   â”‚  â””â”€ tariff_usd_kwh
   â””â”€ Output: dispatch_decision_t
      â”œâ”€ solar_to_ev_kw
      â”œâ”€ solar_to_bess_kw
      â”œâ”€ bess_to_ev_kw
      â”œâ”€ grid_import_kw
      â””â”€ grid_export_kw

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 8: CÃLCULO DINÃMICO DE DEMANDA EV (Layer 8) - DURANTE TRAINING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   ev_demand_calculator.py (314 lÃ­neas)

   Para cada EV:
   â”œâ”€ Input:
   â”‚  â”œâ”€ SOC_arrival: 20-30%
   â”‚  â”œâ”€ SOC_target: 80-90%
   â”‚  â”œâ”€ battery_capacity_kwh
   â”‚  â””â”€ charger_power_kw (2kW moto, 3kW mototaxi)
   â”‚
   â”œâ”€ CÃ¡lculos:
   â”‚  â”œâ”€ energy_required = (SOC_target - SOC_arrival) Ã— capacity
   â”‚  â”œâ”€ charging_time = energy_required / charger_power
   â”‚  â””â”€ demand_power = energy_required / available_hours
   â”‚
   â””â”€ Output:
      â”œâ”€ demand_profile[t] (potencia requerida cada hora)
      â””â”€ charging_completion_time

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 9: PREDICCIÃ“N DE TIEMPOS DE CARGA (Layer 9) - DURANTE TRAINING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   charge_predictor.py (373 lÃ­neas)

   BatteryProfile:
   â”œâ”€ capacity_kwh
   â”œâ”€ efficiency_percent
   â”œâ”€ soc_arrival
   â””â”€ soc_target

   ChargeTimingEstimate:
   â”œâ”€ estimated_hours: tiempo para cargar 100%
   â”œâ”€ available_hours: tiempo disponible en playa
   â”œâ”€ charge_percentage: % que se puede cargar
   â”œâ”€ completion_probability: 0-1
   â””â”€ priority_score: 0-1

   Uso: charge_predictor.predict_timing() â†’ ChargeTimingEstimate

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 10: ENTRENAMIENTO RL (Layer 10) - MAIN LOOP
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   AGENT LOOP (SAC, PPO, A2C):

   for episode in range(num_episodes):
       obs, info = env.reset()
       for step in range(8760):

           â”Œâ”€ AGENT DECISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ action = agent.predict(obs)                    â”‚
           â”‚ â””â”€ action[0-128]: normalized power setpoints   â”‚
           â”‚    â””â”€ [BESS, 128 chargers]                     â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

           â”Œâ”€ ENVIRONMENT STEP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ obs, reward, terminated, truncated, info       â”‚
           â”‚ = env.step(action)                             â”‚
           â”‚                                                â”‚
           â”‚ Internamente:                                  â”‚
           â”‚ â”œâ”€ dispatcher.py: Ejecuta reglas despacho      â”‚
           â”‚ â”œâ”€ ev_demand_calculator: Recalcula demanda     â”‚
           â”‚ â”œâ”€ charger_monitor: Monitorea estado           â”‚
           â”‚ â”œâ”€ charge_predictor: Predice tiempos           â”‚
           â”‚ â””â”€ reward_fn(obs, action) â†’ COâ‚‚ minimizado     â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

           â”Œâ”€ LEARNING UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ agent.learn_from_batch(batch)                  â”‚
           â”‚ â”œâ”€ Update policy Ï€(a|s)                        â”‚
           â”‚ â”œâ”€ Update value function V(s)                  â”‚
           â”‚ â”œâ”€ Update entropy regularization               â”‚
           â”‚ â””â”€ Apply clipping & gradient normalization     â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   Checkpoints:
   â”œâ”€ checkpoints/SAC/sac_step_50000.zip
   â”œâ”€ checkpoints/PPO/ppo_step_75000.zip
   â””â”€ checkpoints/A2C/a2c_step_60000.zip

   Progress Tracking:
   â”œâ”€ progress/sac_progress.csv
   â”‚  â”œâ”€ timestamp, agent, episode, reward, length, global_step
   â”‚  â””â”€ Log cada episodio (8,760 steps)
   â””â”€ progress/sac_progress.png (grÃ¡fico)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


FASE 11: COMPARACIÃ“N DE AGENTES (Layer 11) - POST-TRAINING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   co2_table.py (470 lÃ­neas)

   Input:
   â”œâ”€ checkpoint files (SAC, PPO, A2C trained models)
   â””â”€ summary.json con resultados de todos los entrenamientos

   Procesa:
   â”œâ”€ Para cada agente:
   â”‚  â”œâ”€ Simula aÃ±o completo (8,760 timesteps)
   â”‚  â”œâ”€ Colecta mÃ©tricas:
   â”‚  â”‚  â”œâ”€ ev_kwh_anual
   â”‚  â”‚  â”œâ”€ pv_kwh_anual
   â”‚  â”‚  â”œâ”€ import_red_kwh_anual
   â”‚  â”‚  â”œâ”€ carbon_kg_anual â† MÃ‰TRICA CLAVE
   â”‚  â”‚  â””â”€ autosuficiencia_pct
   â”‚  â””â”€ Calcula rewards multiobjetivo:
   â”‚     â”œâ”€ reward_co2_mean
   â”‚     â”œâ”€ reward_cost_mean
   â”‚     â”œâ”€ reward_solar_mean
   â”‚     â”œâ”€ reward_ev_mean
   â”‚     â””â”€ reward_grid_mean
   â”‚
   â””â”€ Compara todos los agentes:
      â”œâ”€ Tabla comparativa (CSV)
      â”œâ”€ Mejor agente por mÃ©trica (COâ‚‚, costo, etc.)
      â””â”€ RecomendaciÃ³n final

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


SÃNTESIS: FLUJO COMPLETO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Layer 1 (Build)     â†’ dataset_builder_consolidated.py
    â†“
Layer 2 (Validate)  â†’ schema_validator.py (optional)
    â†“
Layer 3 (Load)      â†’ CityLearn v2 Environment
    â†“
Layers 4-9 (Runtime) â†’ enriched_observables, charger_monitor, demand_curve,
                       dispatcher, ev_demand_calculator, charge_predictor
    â†“
Layer 10 (Train)    â†’ Agents (SAC, PPO, A2C) with rewards
    â†“
Layer 11 (Compare)  â†’ co2_table.py


ENTRADA ORIGINAL         SALIDA FINAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OE2 Artifacts        â†’   Trained Agents
â”œâ”€ Solar CSV                â”œâ”€ SAC: best_rl_model.zip
â”œâ”€ Chargers JSON            â”œâ”€ PPO: best_rl_model.zip
â”œâ”€ BESS config              â””â”€ A2C: best_rl_model.zip
â”œâ”€ Mall demand         +
                       â†’   Comparison Report
Climate Zone Data           â”œâ”€ agents_comparison.csv
â”œâ”€ COâ‚‚ intensity             â””â”€ best_agent.json
â”œâ”€ Pricing CSV
â””â”€ Weather CSV         +
                       â†’   Metrics & Logs
Constants                   â”œâ”€ progress/sac_progress.csv
â”œâ”€ GRID_CO2_FACTOR           â”œâ”€ progress/ppo_progress.csv
â”œâ”€ EV_KM_PER_KWH            â”œâ”€ progress/a2c_progress.csv
â””â”€ ICE_KGCO2_PER_GALLON     â””â”€ checkpoints/*/final.zip


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


CONCLUSIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Todas las capas estÃ¡n correctamente posicionadas
âœ… No se requiere integraciÃ³n de nuevos mÃ³dulos
âœ… Flujo de datos es unidireccional y limpio
âœ… Cada mÃ³dulo tiene responsabilidad Ãºnica y clara

ESTADO: LISTO PARA ENTRENAMIENTO ğŸš€
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
